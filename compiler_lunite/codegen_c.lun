import "ast.lun" as ast
import "token.lun" as tok
import "string.lun" as string_lib
import "list.lun" as list
import "map.lun" as map
import "io.lun" as io

pub struct CodegenC {
    pub output: string,
    pub indent: int,
    pub method_map: map.Map<string, string>, // method_name -> struct_name
    pub imports: map.Map<string, string>,    // alias -> path
    pub temp_count: int
}

impl CodegenC {
    pub fn new() -> CodegenC {
        return CodegenC { 
            output: "", 
            indent: 0,
            method_map: map.Map<string, string>.new(),
            imports: map.Map<string, string>.new(),
            temp_count: 0
        };
    }
    
    // --- Utility Functions ---

    fn emit(mut self: CodegenC, s: string) {
        self.output = string_lib.concat(self.output, s);
    }
    
    fn emit_line(mut self: CodegenC, s: string) {
        let mut i = 0;
        while (i < self.indent) {
            self.emit("    ");
            i = i + 1;
        }
        self.emit(s);
        self.emit("\n");
    }
    
    fn emit_newline(mut self: CodegenC) {
        self.emit("\n");
    }

    fn next_temp(mut self: CodegenC) -> string {
        self.temp_count = self.temp_count + 1;
        return string_lib.concat("_tmp", string_lib.int_to_string(self.temp_count));
    }

    // --- Pre-pass: Scan for Impl methods and Imports ---
    
    fn scan_program(mut self: CodegenC, p: ast.Program) {
        let mut i = 0;
        while (i < p.items.count) {
            let item = p.items.data[i];
            when (item) {
                ast.Item::Impl(impl_decl) => {
                    let mut j = 0;
                    while (j < impl_decl.methods.count) {
                        let method = impl_decl.methods.data[j];
                        self.method_map.put(method.name, impl_decl.struct_name);
                        j = j + 1;
                    }
                }
                ast.Item::Import(imp_decl) => {
                    let alias = "";
                    when (imp_decl.alias) {
                        ast.Option::Some(a) => { alias = a; }
                        else => { 
                            alias = imp_decl.path; 
                        }
                    }
                    self.imports.put(alias, imp_decl.path);
                }
                else => {}
            }
            i = i + 1;
        }
    }

    // --- Type Generation ---

    fn gen_type(self: CodegenC, t: ast.Type) -> string {
        when (t) {
            ast.Type::Int => { return "int64_t"; }
            ast.Type::Float => { return "double"; }
            ast.Type::Bool => { return "int"; }
            ast.Type::String => { return "LuniteString*"; }
            ast.Type::Void => { return "void"; }
            ast.Type::Pointer(inner) => {
                return string_lib.concat(self.gen_type(*inner), "*");
            }
            ast.Type::Custom(payload) => {
                return string_lib.concat("struct ", payload.name);
            }
            ast.Type::Enum(payload) => {
                return string_lib.concat("struct ", payload.name);
            }
            ast.Type::Option(inner) => {
                 return "void*"; 
            }
            else => { return "void*"; }
        }
    }

    // --- C Header & Runtime ---
    
    fn gen_header(mut self: CodegenC) {
        self.emit_line("// Generated by Lunite Self-Hosted Compiler");
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdlib.h>");
        self.emit_line("#include <string.h>");
        self.emit_line("#include <stdio.h>");
        self.emit_newline();
        
        self.emit_line("// --- Runtime ---");
        self.emit_line("typedef struct { char* ptr; size_t len; } LuniteString;");
        self.emit_line("LuniteString* lunite_new_string(const char* s) {");
        self.emit_line("    LuniteString* str = malloc(sizeof(LuniteString));");
        self.emit_line("    str->len = strlen(s);");
        self.emit_line("    str->ptr = malloc(str->len + 1);");
        self.emit_line("    strcpy(str->ptr, s);");
        self.emit_line("    return str;");
        self.emit_line("}");
        self.emit_line("int64_t lunite_str_len_runtime(LuniteString* s) { return s ? s->len : 0; }");
        self.emit_line("LuniteString* lunite_str_concat(LuniteString* a, LuniteString* b) {");
        self.emit_line("    if (!a) return b; if (!b) return a;");
        self.emit_line("    LuniteString* res = malloc(sizeof(LuniteString));");
        self.emit_line("    res->len = a->len + b->len;");
        self.emit_line("    res->ptr = malloc(res->len + 1);");
        self.emit_line("    memcpy(res->ptr, a->ptr, a->len);");
        self.emit_line("    memcpy(res->ptr + a->len, b->ptr, b->len);");
        self.emit_line("    res->ptr[res->len] = 0;");
        self.emit_line("    return res;");
        self.emit_line("}");
        self.emit_line("void lunite_print(LuniteString* s) { if(s) printf(\"%s\", s->ptr); }");
        self.emit_line("void lunite_println(LuniteString* s) { if(s) printf(\"%s\n\", s->ptr); else printf(\"\n\"); }");
        self.emit_line("char* lunite_int_to_string(int64_t i) {");
        self.emit_line("    char buf[32]; sprintf(buf, \"%lld\", i);");
        self.emit_line("    return lunite_new_string(buf);");
        self.emit_line("}");
        self.emit_newline();
    }

    // --- Declarations ---

    fn gen_struct_decl(mut self: CodegenC, s: ast.StructDecl) {
        self.emit_line(string_lib.concat(string_lib.concat("typedef struct ", s.name), " {"));
        self.indent = self.indent + 1;
        let mut i = 0;
        while (i < s.fields.count) {
            let f = s.fields.data[i];
            let type_str = self.gen_type(f.typ);
            self.emit_line(string_lib.concat(string_lib.concat(type_str, " "), f.name), ";");
            i = i + 1;
        }
        self.indent = self.indent - 1;
        self.emit_line(string_lib.concat(string_lib.concat("} ", s.name), ";"));
        self.emit_newline();
    }

    fn gen_enum_decl(mut self: CodegenC, e: ast.EnumDecl) {
        let mut i = 0;
        while (i < e.variants.count) {
            let v = e.variants.data[i];
            let tag_name = string_lib.concat(string_lib.concat(e.name, "_"), v.name);
            self.emit_line(string_lib.concat(string_lib.concat("#define ", tag_name), string_lib.concat(" ", string_lib.int_to_string(i))));
            i = i + 1;
        }
        
        self.emit_line(string_lib.concat(string_lib.concat("typedef struct ", e.name), " {"));
        self.indent = self.indent + 1;
        self.emit_line("int tag;");
        self.emit_line("void* payload;");
        self.indent = self.indent - 1;
        self.emit_line(string_lib.concat(string_lib.concat("} ", e.name), ";"));
        self.emit_newline();
    }

    fn gen_function_proto(mut self: CodegenC, f: ast.FunctionDecl, struct_name: string) {
        let ret_type = self.gen_type(f.return_type);
        let mut name = f.name;
        if (string_lib.length(struct_name) > 0) {
            name = string_lib.concat(struct_name, string_lib.concat("_", f.name));
        }
        
        let mut params_str = "";
        let mut i = 0;
        while (i < f.params.count) {
            if (i > 0) { params_str = string_lib.concat(params_str, ", "); }
            let p = f.params.data[i];
            let mut p_type = self.gen_type(p.typ);
            if (p.is_mut) {
                // Check if p_type ends with "*"
                let len = string_lib.length(p_type);
                let ends_with_star = false;
                if (len > 0) {
                    if (string_lib.char_at(p_type, len - 1) == 42) { // 42 is '*'
                        ends_with_star = true;
                    }
                }
                
                if (!ends_with_star) {
                   p_type = string_lib.concat(p_type, "*"); 
                }
            }
            params_str = string_lib.concat(params_str, string_lib.concat(string_lib.concat(p_type, " "), p.name));
            i = i + 1;
        }
        
        self.emit_line(string_lib.concat(string_lib.concat(string_lib.concat(string_lib.concat(ret_type, " "), name), "("), string_lib.concat(params_str, ");")));
    }

    // --- Expression Generation ---

    fn gen_expr(mut self: CodegenC, e: ast.Expression) -> string {
        when (e) {
            ast.Expression::Int(n) => { return string_lib.int_to_string(n); }
            ast.Expression::Boolean(b) => { 
                if (b) { return "1"; }
                return "0";
            }
            ast.Expression::Null => { return "NULL"; }
            ast.Expression::String(s) => { 
                return string_lib.concat(string_lib.concat("lunite_new_string(\"", s), "\")"); 
            }
            ast.Expression::Identifier(name) => { return name; }
            
            ast.Expression::Binary(payload) => {
                let left = self.gen_expr(*payload.left);
                let right = self.gen_expr(*payload.right);
                if (payload.operator == tok.TokenKind::Plus) {
                     // TODO
                }
                let op = self.gen_op(payload.operator);
                return string_lib.concat(string_lib.concat(string_lib.concat(left, op), right));
            }
            
            ast.Expression::Call(payload) => {
                let mut func_name = "";
                let mut first_arg = "";
                
                when (*payload.function) {
                    ast.Expression::MemberAccess(ma) => {
                        let obj_expr = self.gen_expr(*ma.object);
                        
                        if (self.imports.contains(obj_expr)) {
                             func_name = string_lib.concat(obj_expr, string_lib.concat("_", ma.field));
                        } else {
                            let method_name = ma.field;
                            let struct_name = self.method_map.get(method_name);
                            
                            if (struct_name != null) {
                                func_name = string_lib.concat(struct_name, string_lib.concat("_", method_name));
                                first_arg = obj_expr;
                            } else {
                                return string_lib.concat(string_lib.concat(obj_expr, "->"), ma.field);
                            }
                        }
                    }
                    ast.Expression::Identifier(id) => {
                        func_name = id;
                    }
                    else => { func_name = self.gen_expr(*payload.function); }
                }

                let mut args_str = first_arg;
                let mut i = 0;
                while (i < payload.args.count) {
                    if (string_lib.length(args_str) > 0) { args_str = string_lib.concat(args_str, ", "); }
                    args_str = string_lib.concat(args_str, self.gen_expr(payload.args.data[i]));
                    i = i + 1;
                }
                
                return string_lib.concat(string_lib.concat(string_lib.concat(func_name, "("), args_str), ")");
            }
            
            ast.Expression::MemberAccess(payload) => {
                 let obj = self.gen_expr(*payload.object);
                 return string_lib.concat(string_lib.concat(obj, "->"), payload.field);
            }
            
            ast.Expression::StructInit(payload) => {
                 let mut init = string_lib.concat(string_lib.concat("(struct ", payload.name), "){ ");
                 let mut i = 0;
                 while (i < payload.fields.count) {
                     let f = payload.fields.data[i];
                     if (i > 0) { init = string_lib.concat(init, ", "); }
                     init = string_lib.concat(init, string_lib.concat(string_lib.concat(".", f.name), " = "));
                     init = string_lib.concat(init, self.gen_expr(f.expr));
                     i = i + 1;
                 }
                 return string_lib.concat(init, " }");
            }
            
            else => { return "/* expr? */"; }
        }
    }
    
    fn gen_op(self: CodegenC, op: tok.TokenKind) -> string {
        when (op) {
            tok.TokenKind::Plus => { return "+"; }
            tok.TokenKind::Minus => { return "-"; }
            tok.TokenKind::EqualEqual => { return "=="; }
            tok.TokenKind::BangEqual => { return "!="; }
            else => { return "+"; }
        }
    }

    // --- Statement Generation ---

    fn gen_stmt(mut self: CodegenC, s: ast.Statement) {
        when (s) {
            ast.Statement::Let(payload) => {
                let mut type_str = "void*";
                when (payload.type_name) {
                    ast.Option::Some(t) => { type_str = self.gen_type(t); }
                    else => {}
                }
                
                self.emit_line(string_lib.concat(string_lib.concat(type_str, " "), payload.name), ";");
                when (payload.value) {
                    ast.Option::Some(v) => {
                        self.emit_line(string_lib.concat(string_lib.concat(payload.name, " = "), self.gen_expr(v)), ";");
                    }
                    else => {}
                }
            }
            ast.Statement::Return(opt) => {
                when (opt) {
                    ast.Option::Some(e) => {
                        self.emit_line(string_lib.concat("return ", self.gen_expr(e)), ";");
                    }
                    else => { self.emit_line("return;"); }
                }
            }
            ast.Statement::Expr(e) => {
                self.emit_line(string_lib.concat(self.gen_expr(e), ";"));
            }
            ast.Statement::If(payload) => {
                self.emit_line(string_lib.concat("if (", self.gen_expr(payload.condition)), ") {");
                self.indent = self.indent + 1;
                self.gen_block(payload.then_branch);
                self.indent = self.indent - 1;
                when (payload.else_branch) {
                    ast.Option::Some(b) => {
                        self.emit_line("} else {");
                        self.indent = self.indent + 1;
                        self.gen_block(b);
                        self.indent = self.indent - 1;
                    }
                    else => {}
                }
                self.emit_line("}");
            }
            ast.Statement::While(payload) => {
                 self.emit_line(string_lib.concat("while (", self.gen_expr(payload.condition)), ") {");
                 self.indent = self.indent + 1;
                 self.gen_block(payload.body);
                 self.indent = self.indent - 1;
                 self.emit_line("}");
            }
            ast.Statement::When(payload) => {
                let subject_var = self.next_temp();
                self.emit_line(string_lib.concat(string_lib.concat("void* ", subject_var), " = ")); 
                self.emit(self.gen_expr(payload.subject));
                self.emit("\n");
                
                let mut first = true;
                let mut i = 0;
                while (i < payload.arms.count) {
                    let arm = payload.arms.data[i];
                    if (!first) { self.emit(" else "); }
                    first = false;
                    
                    when (arm.pattern) {
                        ast.WhenPattern::EnumVariant(ev) => {
                            let tag_const = string_lib.concat(string_lib.concat(ev.enum_name, "_"), ev.variant_name);
                            let cast = string_lib.concat(string_lib.concat("(struct ", ev.enum_name), ")*");
                            let access = string_lib.concat(string_lib.concat(cast, subject_var), ".tag");
                            
                            self.emit(string_lib.concat(string_lib.concat("if (", access), " == "));
                            self.emit(tag_const);
                            self.emit(") {");
                            
                            when (ev.binding) {
                                ast.Option::Some(bname) => {
                                     self.emit_newline();
                                     self.indent = self.indent + 1;
                                     self.emit_line(string_lib.concat(string_lib.concat(string_lib.concat("void* ", bname), string_lib.concat(" = ((struct ", ev.enum_name)), ")*)subject)->payload;")); 
                                     self.indent = self.indent - 1;
                                }
                                else => {}
                            }
                        }
                        ast.WhenPattern::Else => {
                            self.emit("if (1) {");
                        }
                        else => { self.emit("if (0) { /* other pat */"); }
                    }
                    
                    self.indent = self.indent + 1;
                    self.gen_block(arm.body);
                    self.indent = self.indent - 1;
                    self.emit_line("}");
                    i = i + 1;
                }
            }
            else => {}
        }
    }

    fn gen_block(mut self: CodegenC, b: ast.Block) {
        let mut i = 0;
        while (i < b.statements.count) {
            self.gen_stmt(b.statements.data[i]);
            i = i + 1;
        }
    }

    // --- Main Entry ---

    pub fn generate(mut self: CodegenC, p: ast.Program) -> string {
        self.scan_program(p);
        self.gen_header();
        
        let mut i = 0;
        while (i < p.items.count) {
            when (p.items.data[i]) {
                ast.Item::Struct(s) => { self.gen_struct_decl(s); }
                ast.Item::Enum(e) => { self.gen_enum_decl(e); }
                else => {}
            }
            i = i + 1;
        }

        i = 0;
        while (i < p.items.count) {
            when (p.items.data[i]) {
                ast.Item::Function(f) => { self.gen_function_proto(f, ""); }
                ast.Item::Impl(imp) => {
                    let mut j = 0;
                    while (j < imp.methods.count) {
                        self.gen_function_proto(imp.methods.data[j], imp.struct_name);
                        j = j + 1;
                    }
                }
                else => {}
            }
            i = i + 1;
        }

        i = 0;
        while (i < p.items.count) {
            when (p.items.data[i]) {
                ast.Item::Function(f) => {
                    self.gen_function_def(f, "");
                }
                ast.Item::Impl(imp) => {
                    let mut j = 0;
                    while (j < imp.methods.count) {
                        self.gen_function_def(imp.methods.data[j], imp.struct_name);
                        j = j + 1;
                    }
                }
                else => {}
            }
            i = i + 1;
        }
        
        return self.output;
    }

    fn gen_function_def(mut self: CodegenC, f: ast.FunctionDecl, struct_name: string) {
        let ret_type = self.gen_type(f.return_type);
        let mut name = f.name;
        if (string_lib.length(struct_name) > 0) {
            name = string_lib.concat(struct_name, string_lib.concat("_", f.name));
        }
        
        let mut params_str = "";
        let mut i = 0;
        while (i < f.params.count) {
            if (i > 0) { params_str = string_lib.concat(params_str, ", "); }
            let p = f.params.data[i];
            let mut p_type = self.gen_type(p.typ);
             if (p.is_mut) {
                // Check if p_type ends with "*"
                let len = string_lib.length(p_type);
                let ends_with_star = false;
                if (len > 0) {
                    if (string_lib.char_at(p_type, len - 1) == 42) { // 42 is '*'
                        ends_with_star = true;
                    }
                }
                
                if (!ends_with_star) {
                   p_type = string_lib.concat(p_type, "*"); 
                }
            }
            params_str = string_lib.concat(params_str, string_lib.concat(string_lib.concat(p_type, " "), p.name));
            i = i + 1;
        }
        
        self.emit_line(string_lib.concat(string_lib.concat(string_lib.concat(string_lib.concat(ret_type, " "), name), "("), string_lib.concat(params_str, ") {")));
        self.indent = self.indent + 1;
        self.gen_block(f.body);
        self.indent = self.indent - 1;
        self.emit_line("}");
        self.emit_newline();
    }
}
