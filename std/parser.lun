import "lexer.lun" as lex
import "token.lun" as tok
import "ast.lun" as ast
import "list.lun" as list
import "map.lun" as map

pub struct Parser {
    pub l: lex.Lexer,
    pub cur_token: tok.Token,
    pub peek_token: tok.Token
}

impl Parser {
    pub fn new(l: lex.Lexer) -> Parser {
        let p = Parser {
            l: l,
            cur_token: tok.Token { kind: tok.TokenKind::Illegal, line: 0, column: 0 },
            peek_token: tok.Token { kind: tok.TokenKind::Illegal, line: 0, column: 0 }
        };
        p.next_token();
        p.next_token();
        return p;
    }

    pub fn next_token(self: Parser) {
        self.cur_token = self.peek_token;
        self.peek_token = self.l.next_token();
    }

    pub fn parse_program(self: Parser) -> ast.Program {
        let items = list.List<ast.Item>.new();
        while (self.cur_token.kind != tok.TokenKind::EOF) {
            if (self.cur_token.kind == tok.TokenKind::TokFn) {
                let f = self.parse_function();
                if (f != null) { items.push(ast.Item::Function(f)); }
            } else if (self.cur_token.kind == tok.TokenKind::TokStruct) {
                let s = self.parse_struct();
                if (s != null) { items.push(ast.Item::Struct(s)); }
            } else if (self.cur_token.kind == tok.TokenKind::TokEnum) {
                let e = self.parse_enum();
                if (e != null) { items.push(ast.Item::Enum(e)); }
            } else {
                self.next_token();
            }
        }
        return ast.Program { items: items };
    }

    pub fn parse_struct(self: Parser) -> ast.StructDecl {
        self.next_token(); // struct
        let name = "";
        when (self.cur_token.kind) {
            tok.TokenKind::Identifier(n) => { name = n; },
            else => { return null; }
        }
        self.next_token(); // name

        if (self.cur_token.kind != tok.TokenKind::TokLBrace) { return null; }
        self.next_token(); // {

        let fields = list.List<map.MapEntry<string, ast.Type> >.new();
        while (self.cur_token.kind != tok.TokenKind::TokRBrace && self.cur_token.kind != tok.TokenKind::EOF) {
            let field_name = "";
            when (self.cur_token.kind) {
                tok.TokenKind::Identifier(n) => { field_name = n; },
                else => { self.next_token(); }
            }
            if (field_name != "") {
                self.next_token();
                if (self.cur_token.kind == tok.TokenKind::TokColon) {
                    self.next_token();
                    let t = self.parse_type();
                    fields.push(map.MapEntry<string, ast.Type> { key: field_name, value: t });
                }
                if (self.cur_token.kind == tok.TokenKind::TokComma) { self.next_token(); }
            }
        }
        if (self.cur_token.kind == tok.TokenKind::TokRBrace) { self.next_token(); }
        return ast.StructDecl { name: name, fields: fields };
    }

    pub fn parse_enum(self: Parser) -> ast.EnumDecl {
        self.next_token(); // enum
        let name = "";
        when (self.cur_token.kind) {
            tok.TokenKind::Identifier(n) => { name = n; },
            else => { return null; }
        }
        self.next_token(); // name

        if (self.cur_token.kind != tok.TokenKind::TokLBrace) { return null; }
        self.next_token(); // {

        let variants = list.List<ast.EnumVariant>.new();
        while (self.cur_token.kind != tok.TokenKind::TokRBrace && self.cur_token.kind != tok.TokenKind::EOF) {
            let v_name = "";
            when (self.cur_token.kind) {
                tok.TokenKind::Identifier(n) => { v_name = n; },
                else => { self.next_token(); }
            }
            if (v_name != "") {
                self.next_token();
                let v_type = ast.Type::Void;
                if (self.cur_token.kind == tok.TokenKind::TokLParen) {
                    self.next_token();
                    v_type = self.parse_type();
                    if (self.cur_token.kind == tok.TokenKind::TokRParen) { self.next_token(); }
                }
                variants.push(ast.EnumVariant { name: v_name, typ: v_type });
                if (self.cur_token.kind == tok.TokenKind::TokComma) { self.next_token(); }
            }
        }
        if (self.cur_token.kind == tok.TokenKind::TokRBrace) { self.next_token(); }
        return ast.EnumDecl { name: name, variants: variants };
    }

    pub fn parse_type(self: Parser) -> ast.Type {
        when (self.cur_token.kind) {
            tok.TokenKind::TypeInt => { self.next_token(); return ast.Type::Int; },
            tok.TokenKind::KindString => { self.next_token(); return ast.Type::String; },
            tok.TokenKind::TypeVoid => { self.next_token(); return ast.Type::Void; },
            tok.TokenKind::Identifier(n) => { self.next_token(); return ast.Type::Custom(n); },
            else => { self.next_token(); return ast.Type::Void; }
        }
    }

    pub fn parse_function(self: Parser) -> ast.FunctionDecl {
        self.next_token(); // fn
        
        let name = "";
        when (self.cur_token.kind) {
            tok.TokenKind::Identifier(n) => { name = n; },
            else => { return null; }
        }
        self.next_token(); // name

        if (self.cur_token.kind == tok.TokenKind::TokLParen) { self.next_token(); }
        while (self.cur_token.kind != tok.TokenKind::TokRParen && self.cur_token.kind != tok.TokenKind::EOF) {
            self.next_token();
        }
        if (self.cur_token.kind == tok.TokenKind::TokRParen) { self.next_token(); }

        let ret_type = ast.Type::Void;
        if (self.cur_token.kind == tok.TokenKind::TokArrow) {
            self.next_token(); // ->
            if (self.cur_token.kind == tok.TokenKind::TypeVoid) { ret_type = ast.Type::Void; self.next_token(); }
            else if (self.cur_token.kind == tok.TokenKind::TypeInt) { ret_type = ast.Type::Int; self.next_token(); }
        }

        let body_stmts = self.parse_block();
        
        return ast.FunctionDecl {
            name: name,
            params: list.List<map.MapEntry<string, ast.Type> >.new(),
            return_type: ret_type,
            body: body_stmts
        };
    }

    pub fn parse_block(self: Parser) -> list.List<ast.Statement> {
        let stmts = list.List<ast.Statement>.new();
        if (self.cur_token.kind == tok.TokenKind::TokLBrace) {
            self.next_token(); // {
            while (self.cur_token.kind != tok.TokenKind::TokRBrace && self.cur_token.kind != tok.TokenKind::EOF) {
                let stmt = self.parse_statement();
                if (stmt != null) { stmts.push(stmt); }
                else { self.next_token(); }
            }
            if (self.cur_token.kind == tok.TokenKind::TokRBrace) { self.next_token(); }
        }
        return stmts;
    }

    pub fn parse_statement(self: Parser) -> ast.Statement {
        if (self.cur_token.kind == tok.TokenKind::TokLet) { return self.parse_let_statement(); }
        if (self.cur_token.kind == tok.TokenKind::TokReturn) { return self.parse_return_statement(); }
        if (self.cur_token.kind == tok.TokenKind::TokIf) { return self.parse_if_statement(); }
        if (self.cur_token.kind == tok.TokenKind::TokWhile) { return self.parse_while_statement(); }
        return self.parse_expression_statement();
    }

    pub fn parse_if_statement(self: Parser) -> ast.Statement {
        self.next_token(); // if
        let cond = self.parse_expression(0);
        let then_branch = self.parse_block();
        let else_branch = list.List<ast.Statement>.new();
        if (self.cur_token.kind == tok.TokenKind::TokElse) {
            self.next_token();
            else_branch = self.parse_block();
        }
        return ast.Statement::If(ast.IfStmt { cond: cond, then_branch: then_branch, else_branch: else_branch });
    }

    pub fn parse_while_statement(self: Parser) -> ast.Statement {
        self.next_token(); // while
        let cond = self.parse_expression(0);
        let body = self.parse_block();
        return ast.Statement::While(ast.WhileStmt { cond: cond, body: body });
    }

    pub fn parse_let_statement(self: Parser) -> ast.Statement {
        self.next_token(); // let
        let name = "";
        when (self.cur_token.kind) {
            tok.TokenKind::Identifier(n) => { name = n; },
            else => { return null; }
        }
        self.next_token(); // name

        let t = ast.Type::Int;
        if (self.cur_token.kind == tok.TokenKind::TokColon) {
            self.next_token();
            t = self.parse_type();
        }

        if (self.cur_token.kind == tok.TokenKind::TokEqual) {
            self.next_token();
        }

        let expr = self.parse_expression(0);
        
        if (self.cur_token.kind == tok.TokenKind::TokSemicolon) {
            self.next_token();
        }

        let s = ast.LetStmt { name: name, typ: t, val: expr };
        return ast.Statement::Let(s);
    }

    pub fn parse_return_statement(self: Parser) -> ast.Statement {
        self.next_token(); // return
        let expr = self.parse_expression(0);
        if (self.cur_token.kind == tok.TokenKind::TokSemicolon) {
            self.next_token();
        }
        return ast.Statement::Return(expr);
    }

    pub fn parse_expression_statement(self: Parser) -> ast.Statement {
        let expr = self.parse_expression(0);
        if (self.cur_token.kind == tok.TokenKind::TokSemicolon) {
            self.next_token();
        }
        if (expr == null) { return null; }
        return ast.Statement::Expr(expr);
    }

    pub fn get_precedence(self: Parser, kind: tok.TokenKind) -> int {
        when (kind) {
            tok.TokenKind::TokPlus => { return 10; },
            tok.TokenKind::TokMinus => { return 10; },
            tok.TokenKind::TokStar => { return 20; },
            tok.TokenKind::TokSlash => { return 20; },
            tok.TokenKind::TokEqualEqual => { return 5; },
            tok.TokenKind::TokBangEqual => { return 5; },
            else => { return 0; }
        }
    }

    pub fn parse_expression(self: Parser, precedence: int) -> ast.Expression {
        let left = self.parse_prefix();
        if (left == null) { return null; }
        
        while (precedence < self.get_precedence(self.cur_token.kind)) {
            let op = self.cur_token.kind;
            self.next_token();
            let right = self.parse_expression(self.get_precedence(op));
            let binary = ast.BinaryExpr { left: left, op: op, right: right };
            left = ast.Expression { kind: ast.ExpressionKind::Binary(binary), typ: ast.Type::Void };
        }
        
        return left;
    }

    pub fn parse_prefix(self: Parser) -> ast.Expression {
        when (self.cur_token.kind) {
            tok.TokenKind::Identifier(name) => {
                self.next_token();
                if (self.cur_token.kind == tok.TokenKind::TokLParen) {
                    self.next_token(); // (
                    let args = list.List<ast.Expression>.new();
                    if (self.cur_token.kind != tok.TokenKind::TokRParen) {
                         let arg = self.parse_expression(0);
                         if (arg != null) { args.push(arg); }
                         while (self.cur_token.kind == tok.TokenKind::TokComma) {
                             self.next_token();
                             let arg2 = self.parse_expression(0);
                             if (arg2 != null) { args.push(arg2); }
                         }
                    }
                    if (self.cur_token.kind == tok.TokenKind::TokRParen) { self.next_token(); }
                    
                    let c = ast.CallExpr { 
                        func: ast.Expression { kind: ast.ExpressionKind::Identifier(name), typ: ast.Type::Void },
                        args: args
                    };
                    return ast.Expression { kind: ast.ExpressionKind::Call(c), typ: ast.Type::Void };
                }
                return ast.Expression { kind: ast.ExpressionKind::Identifier(name), typ: ast.Type::Int };
            },
            tok.TokenKind::IntLiteral(val) => {
                self.next_token();
                return ast.Expression { kind: ast.ExpressionKind::IntLiteral(val), typ: ast.Type::Int };
            },
            tok.TokenKind::StringLiteral(s) => {
                self.next_token();
                return ast.Expression { kind: ast.ExpressionKind::StringLiteral(s), typ: ast.Type::String };
            },
            else => { return null; }
        }
    }
}