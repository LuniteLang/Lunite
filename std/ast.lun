import "list.lun" as list
import "token.lun" as tok

pub enum Option<T> {
    Some(T),
    None
}

pub enum Visibility {
    Public,
    Private
}

pub enum Type {
    Int,
    Float,
    Bool,
    String,
    Void,
    Custom(CustomTypePayload),
    Enum(EnumTypePayload),
    Array(ArrayTypePayload),
    Pointer(*Type),
    Function(FunctionTypePayload),
    Result(ResultTypePayload),
    Option(*Type),
    Null
}

pub struct CustomTypePayload {
    pub name: string,
    pub type_args: list.List<Type>
}

pub struct EnumTypePayload {
    pub name: string,
    pub type_args: list.List<Type>
}

pub struct ArrayTypePayload {
    pub inner: *Type,
    pub size: int
}

pub struct FunctionTypePayload {
    pub params: list.List<Type>,
    pub return_type: *Type
}

pub struct ResultTypePayload {
    pub ok_type: *Type,
    pub err_type: *Type
}

pub struct Program {
    pub items: list.List<Item>
}

pub enum Item {
    Import(ImportDecl),
    Function(FunctionDecl),
    NativeFunction(NativeFunctionDecl),
    ExternFunction(ExternFunctionDecl),
    Struct(StructDecl),
    Enum(EnumDecl),
    Impl(ImplDecl)
}

pub struct ImportDecl {
    pub path: string,
    pub alias: Option<string>
}

pub struct ImplDecl {
    pub struct_name: string,
    pub generic_params: list.List<string>,
    pub methods: list.List<FunctionDecl>
}

pub struct NativeFunctionDecl {
    pub name: string,
    pub generic_params: list.List<string>,
    pub params: list.List<Param>,
    pub return_type: Type,
    pub visibility: Visibility
}

pub struct ExternFunctionDecl {
    pub name: string,
    pub generic_params: list.List<string>,
    pub params: list.List<Param>,
    pub return_type: Type
}

pub struct Param {
    pub name: string,
    pub typ: Type,
    pub is_mut: bool
}

pub enum StructLayout {
    Aos,
    Soa
}

pub struct StructDecl {
    pub name: string,
    pub generic_params: list.List<string>,
    pub fields: list.List<Field>,
    pub visibility: Visibility,
    pub st_layout: StructLayout
}

pub struct Field {
    pub name: string,
    pub typ: Type,
    pub visibility: Visibility
}

pub struct EnumDecl {
    pub name: string,
    pub generic_params: list.List<string>,
    pub variants: list.List<EnumVariant>,
    pub visibility: Visibility
}

pub struct EnumVariant {
    pub name: string,
    pub typ: Option<Type>
}

pub struct FunctionDecl {
    pub name: string,
    pub generic_params: list.List<string>,
    pub params: list.List<Param>,
    pub return_type: Type,
    pub body: Block,
    pub visibility: Visibility,
    pub is_pure: bool,
    pub contract: Option<Expression>
}

pub struct Block {
    pub statements: list.List<Statement>
}

pub enum Statement {
    Let(LetStatementPayload),
    Assign(AssignStatementPayload),
    Return(Option<Expression>),
    If(IfStatementPayload),
    While(WhileStatementPayload),
    Region(RegionStatementPayload),
    Spawn(Expression),
    For(ForStatementPayload),
    When(WhenStatementPayload),
    Throw(ThrowStatementPayload),
    TryCatch(TryCatchStatementPayload),
    Expr(Expression),
    Block(Block)
}

pub struct LetStatementPayload {
    pub name: string,
    pub is_mutable: bool,
    pub type_name: Option<Type>,
    pub value: Option<Expression>
}

pub struct AssignStatementPayload {
    pub lvalue: Expression,
    pub value: Expression
}

pub struct IfStatementPayload {
    pub condition: Expression,
    pub then_branch: Block,
    pub else_branch: Option<Block>
}

pub struct WhileStatementPayload {
    pub condition: Expression,
    pub body: Block
}

pub struct RegionStatementPayload {
    pub body: Block
}

pub struct ForStatementPayload {
    pub variable: string,
    pub start: Expression,
    pub end: Expression,
    pub body: Block
}

pub struct WhenStatementPayload {
    pub subject: Expression,
    pub arms: list.List<WhenArm>
}

pub struct ThrowStatementPayload {
    pub value: Expression
}

pub struct TryCatchStatementPayload {
    pub try_block: Block,
    pub catch_variable: string,
    pub catch_block: Block
}

pub struct WhenArm {
    pub pattern: WhenPattern,
    pub body: Block
}

pub enum WhenPattern {
    Literal(Expression),
    Range(RangePatternPayload),
    EnumVariant(EnumVariantPatternPayload),
    Else
}

pub struct RangePatternPayload {
    pub start: Expression,
    pub end: Expression
}

pub struct EnumVariantPatternPayload {
    pub enum_name: string,
    pub variant_name: string,
    pub binding: Option<string>
}

pub enum Expression {
    Int(int),
    Float(float),
    String(string),
    Identifier(string),
    Boolean(bool),
    Null,
    Unary(UnaryExpressionPayload),
    Comptime(Block),
    Binary(BinaryExpressionPayload),
    Call(CallExpressionPayload),
    StructInit(StructInitExpressionPayload),
    EnumInit(EnumInitExpressionPayload),
    ArrayLiteral(list.List<Expression>),
    ArrayRepeat(ArrayRepeatExpressionPayload),
    MemberAccess(MemberAccessExpressionPayload),
    GenericSpecialization(GenericSpecializationExpressionPayload),
    Index(IndexExpressionPayload),
    Cast(CastExpressionPayload),
    Try(*Expression),
    Sizeof(Type)
}

pub struct UnaryExpressionPayload {
    pub operator: tok.TokenKind,
    pub right: *Expression
}

pub struct BinaryExpressionPayload {
    pub left: *Expression,
    pub operator: tok.TokenKind,
    pub right: *Expression
}

pub struct CallExpressionPayload {
    pub function: *Expression,
    pub args: list.List<Expression>,
    pub type_args: list.List<Type>
}

pub struct StructInitExpressionPayload {
    pub name: string,
    pub type_args: list.List<Type>,
    pub fields: list.List<NamedExpression>
}

pub struct EnumInitExpressionPayload {
    pub enum_name: string,
    pub variant_name: string,
    pub type_args: list.List<Type>,
    pub value: Option<*Expression>
}

pub struct ArrayRepeatExpressionPayload {
    pub value: *Expression,
    pub size: int
}

pub struct MemberAccessExpressionPayload {
    pub object: *Expression,
    pub field: string
}

pub struct GenericSpecializationExpressionPayload {
    pub expression: *Expression,
    pub type_args: list.List<Type>
}

pub struct IndexExpressionPayload {
    pub left: *Expression,
    pub index: *Expression
}

pub struct CastExpressionPayload {
    pub expression: *Expression,
    pub target_type: Type
}

pub struct NamedExpression {
    pub name: string,
    pub expr: Expression
}
