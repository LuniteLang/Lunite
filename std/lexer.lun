import "string.lun" as str
import "token.lun" as tok
import "io.lun" as io

pub struct Lexer {
    pub input: string,
    pub pos: int,
    pub read_pos: int,
    pub ch: int,
    pub line: int,
    pub col: int
}

pub fn create(input: string) -> Lexer {
    return Lexer::new(input);
}

impl Lexer {
    pub fn new(input: string) -> Lexer {
        // io.log(io.Level::DEBUG, "Inside Lexer.new");
        str.print("Lexer new");
        let l = Lexer {
            input: input,
            pos: 0,
            read_pos: 0,
            ch: 0,
            line: 1,
            col: 0
        };
        str.print("Calling read_char");
        l.read_char();
        return l;
    }

    pub fn read_char(self: Lexer) {
        let input_len = str.length(self.input);
        if (self.read_pos >= input_len) {
            self.ch = 0;
        } else {
            self.ch = str.char_at(self.input, self.read_pos);
        }
        self.pos = self.read_pos;
        self.read_pos = self.read_pos + 1;
        if (self.ch == 10) {
            self.line = self.line + 1;
            self.col = 0;
        } else {
            self.col = self.col + 1;
        }
    }

    pub fn skip_whitespace(self: Lexer) {
        while ((self.ch == 32) | (self.ch == 9) | (self.ch == 13) | (self.ch == 10)) {
            self.read_char();
        }
    }

    pub fn lookup_keyword(self: Lexer, ident: string) -> tok.TokenKind {
        if (ident == "fn") { return tok.TokenKind::TokFn; }
        else if (ident == "let") { return tok.TokenKind::TokLet; }
        else if (ident == "return") { return tok.TokenKind::TokReturn; }
        else if (ident == "if") { return tok.TokenKind::TokIf; }
        else if (ident == "else") { return tok.TokenKind::TokElse; }
        else if (ident == "while") { return tok.TokenKind::TokWhile; }
        else if (ident == "for") { return tok.TokenKind::TokFor; }
        else if (ident == "in") { return tok.TokenKind::TokIn; }
        else if (ident == "struct") { return tok.TokenKind::TokStruct; }
        else if (ident == "enum") { return tok.TokenKind::TokEnum; }
        else if (ident == "impl") { return tok.TokenKind::TokImpl; }
        else if (ident == "import") { return tok.TokenKind::TokImport; }
        else if (ident == "pub") { return tok.TokenKind::TokPub; }
        else if (ident == "true") { return tok.TokenKind::TokTrue; }
        else if (ident == "false") { return tok.TokenKind::TokFalse; }
        else if (ident == "when") { return tok.TokenKind::TokWhen; }
        else if (ident == "int") { return tok.TokenKind::TypeInt; }
        else if (ident == "string") { return tok.TokenKind::KindString; }
        else if (ident == "void") { return tok.TokenKind::TypeVoid; }
        
        return tok.TokenKind::Identifier(ident);
    }

    pub fn next_token(self: Lexer) -> tok.Token {
        self.skip_whitespace();
        let cur_l = self.line;
        let cur_c = self.col;
        
        if (self.ch == 0) {
            return tok.Token { kind: tok.TokenKind::EOF, line: cur_l, column: cur_c };
        }
        
        let c = self.ch;
        self.read_char();

        let kind = tok.TokenKind::Illegal;

        if (c == 43) { kind = tok.TokenKind::TokPlus; }
        else if (c == 45) {
            if (self.ch == 62) {
                self.read_char();
                kind = tok.TokenKind::TokArrow;
            } else {
                kind = tok.TokenKind::TokMinus;
            }
        }
        else if (c == 42) { kind = tok.TokenKind::TokStar; }
        else if (c == 47) { kind = tok.TokenKind::TokSlash; }
        else if (c == 61) {
            if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::TokEqualEqual;
            } else if (self.ch == 62) {
                self.read_char();
                kind = tok.TokenKind::TokFatArrow;
            } else {
                kind = tok.TokenKind::TokEqual;
            }
        }
        else if (c == 40) { kind = tok.TokenKind::TokLParen; }
        else if (c == 41) { kind = tok.TokenKind::TokRParen; }
        else if (c == 123) { kind = tok.TokenKind::TokLBrace; }
        else if (c == 125) { kind = tok.TokenKind::TokRBrace; }
        else if (c == 58) {
            if (self.ch == 58) {
                self.read_char();
                kind = tok.TokenKind::TokColonColon;
            } else {
                kind = tok.TokenKind::TokColon;
            }
        }
        else if (c == 44) { kind = tok.TokenKind::TokComma; }
        else if (c == 59) { kind = tok.TokenKind::TokSemicolon; }
        else if (c == 60) {
            if (self.ch == 60) {
                self.read_char();
                kind = tok.TokenKind::TokLessLess;
            } else if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::TokLessEqual;
            } else {
                kind = tok.TokenKind::TokLess;
            }
        }
        else if (c == 62) {
            if (self.ch == 62) {
                self.read_char();
                kind = tok.TokenKind::TokGreaterGreater;
            } else if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::TokGreaterEqual;
            } else {
                kind = tok.TokenKind::TokGreater;
            }
        }
        else if (c == 34) {
            kind = tok.TokenKind::StringLiteral(self.read_string());
        }
        else if (self.is_letter_val(c)) {
            let ident = self.read_identifier_with_start(c);
            kind = self.lookup_keyword(ident);
        }
        else if (self.is_digit_val(c)) {
            kind = self.read_number_token_with_start(c);
        }

        return tok.Token { kind: kind, line: cur_l, column: cur_c };
    }

    pub fn is_letter_val(self: Lexer, c: int) -> bool {
        return (c >= 97 && c <= 122) | (c >= 65 && c <= 90) | (c == 95);
    }

    pub fn is_digit_val(self: Lexer, c: int) -> bool {
        return (c >= 48 && c <= 57);
    }

    pub fn read_identifier_with_start(self: Lexer, start_ch: int) -> string {
        let start_pos = self.pos - 1;
        while (self.is_letter_val(self.ch) | self.is_digit_val(self.ch)) {
            self.read_char();
        }
        return str.sub(self.input, start_pos, self.pos);
    }

    pub fn read_number_token_with_start(self: Lexer, start_ch: int) -> tok.TokenKind {
        let start_pos = self.pos - 1;
        while (self.is_digit_val(self.ch)) {
            self.read_char();
        }
        let s = str.sub(self.input, start_pos, self.pos);
        return tok.TokenKind::IntLiteral(self.parse_int(s));
    }

    pub fn parse_int(self: Lexer, s: string) -> int {
        let len = str.length(s);
        let i = 0;
        let res = 0;
        while (len > i) {
            let c = str.char_at(s, i);
            res = res * 10 + (c - 48);
            i = i + 1;
        }
        return res;
    }

    pub fn read_string(self: Lexer) -> string {
        let start_pos = self.pos;
        while (self.ch != 34 && self.ch != 0) {
            if (self.ch == 92) { // \
                self.read_char();
            }
            self.read_char();
        }
        let lit = str.sub(self.input, start_pos, self.pos);
        self.read_char(); // skip closing "
        return lit;
    }
}