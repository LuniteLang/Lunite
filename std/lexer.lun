import "string.lun" as str
import "token.lun" as tok
import "io.lun" as io

pub struct Lexer {
    pub input: string,
    pub pos: int,
    pub read_pos: int,
    pub ch: int,
    pub line: int,
    pub col: int
}

pub fn create(input: string) -> Lexer {
    return Lexer::new(input);
}

impl Lexer {
    pub fn new(input: string) -> Lexer {
        // io.log(io.Level::DEBUG, "Inside Lexer.new");
        str.print("Lexer new");
        let l = Lexer {
            input: input,
            pos: 0,
            read_pos: 0,
            ch: 0,
            line: 1,
            col: 0
        };
        str.print("Calling read_char");
        l.read_char();
        return l;
    }

    pub fn read_char(self: Lexer) {
        let input_len = str.length(self.input);
        if (self.read_pos >= input_len) {
            self.ch = 0;
        } else {
            self.ch = str.char_at(self.input, self.read_pos);
        }
        self.pos = self.read_pos;
        self.read_pos = self.read_pos + 1;
        if (self.ch == 10) {
            self.line = self.line + 1;
            self.col = 0;
        } else {
            self.col = self.col + 1;
        }
    }

    pub fn skip_whitespace(self: Lexer) {
        while ((self.ch == 32) | (self.ch == 9) | (self.ch == 13) | (self.ch == 10)) {
            self.read_char();
        }
    }

    pub fn lookup_keyword(self: Lexer, ident: string) -> tok.TokenKind {
        if (ident == "fn") { return tok.TokenKind::TokFn; }
        else if (ident == "let") { return tok.TokenKind::TokLet; }
        else if (ident == "return") { return tok.TokenKind::TokReturn; }
        else if (ident == "if") { return tok.TokenKind::TokIf; }
        else if (ident == "else") { return tok.TokenKind::TokElse; }
        else if (ident == "while") { return tok.TokenKind::TokWhile; }
        else if (ident == "for") { return tok.TokenKind::TokFor; }
        else if (ident == "in") { return tok.TokenKind::TokIn; }
        else if (ident == "struct") { return tok.TokenKind::TokStruct; }
        else if (ident == "enum") { return tok.TokenKind::TokEnum; }
        else if (ident == "impl") { return tok.TokenKind::TokImpl; }
        else if (ident == "use") { return tok.TokenKind::TokUse; }
        else if (ident == "import") { return tok.TokenKind::TokImport; }
        else if (ident == "extern") { return tok.TokenKind::TokExtern; }
        else if (ident == "native") { return tok.TokenKind::TokNative; }
        else if (ident == "pub") { return tok.TokenKind::TokPub; }
        else if (ident == "pure") { return tok.TokenKind::TokPure; }
        else if (ident == "req") { return tok.TokenKind::TokReq; }
        else if (ident == "layout") { return tok.TokenKind::TokLayout; }
        else if (ident == "soa") { return tok.TokenKind::TokSoa; }
        else if (ident == "as") { return tok.TokenKind::TokAs; }
        else if (ident == "try") { return tok.TokenKind::TokTry; }
        else if (ident == "catch") { return tok.TokenKind::TokCatch; }
        else if (ident == "throw") { return tok.TokenKind::TokThrow; }
        else if (ident == "true") { return tok.TokenKind::TokTrue; }
        else if (ident == "false") { return tok.TokenKind::TokFalse; }
        else if (ident == "null") { return tok.TokenKind::TokNull; }
        else if (ident == "mut") { return tok.TokenKind::TokMut; }
        else if (ident == "when") { return tok.TokenKind::TokWhen; }
        else if (ident == "region") { return tok.TokenKind::TokRegion; }
        else if (ident == "comptime") { return tok.TokenKind::TokComptime; }
        else if (ident == "spawn") { return tok.TokenKind::TokSpawn; }
        else if (ident == "sizeof") { return tok.TokenKind::TokSizeof; }
        else if (ident == "int") { return tok.TokenKind::TypeInt; }
        else if (ident == "float") { return tok.TokenKind::TypeFloat; }
        else if (ident == "bool") { return tok.TokenKind::TypeBool; }
        else if (ident == "string") { return tok.TokenKind::TypeString; }
        else if (ident == "void") { return tok.TokenKind::TypeVoid; }
        
        return tok.TokenKind::Identifier(ident);
    }

    pub fn next_token(self: Lexer) -> tok.Token {
        self.skip_whitespace();
        let cur_l = self.line;
        let cur_c = self.col;
        
        if (self.ch == 0) {
            return tok.Token { kind: tok.TokenKind::Eof, line: cur_l, column: cur_c };
        }
        
        let c = self.ch;
        self.read_char();

        let kind = tok.TokenKind::Illegal;

        if (c == 43) { kind = tok.TokenKind::Plus; }
        else if (c == 45) {
            if (self.ch == 62) {
                self.read_char();
                kind = tok.TokenKind::Arrow;
            } else {
                kind = tok.TokenKind::Minus;
            }
        }
        else if (c == 42) { kind = tok.TokenKind::Star; }
        else if (c == 47) { kind = tok.TokenKind::Slash; }
        else if (c == 37) { kind = tok.TokenKind::Percent; }
        else if (c == 61) {
            if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::EqualEqual;
            } else if (self.ch == 62) {
                self.read_char();
                kind = tok.TokenKind::FatArrow;
            } else {
                kind = tok.TokenKind::Equal;
            }
        }
        else if (c == 33) {
            if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::BangEqual;
            } else {
                kind = tok.TokenKind::Bang;
            }
        }
        else if (c == 40) { kind = tok.TokenKind::LParen; }
        else if (c == 41) { kind = tok.TokenKind::RParen; }
        else if (c == 123) { kind = tok.TokenKind::LBrace; }
        else if (c == 125) { kind = tok.TokenKind::RBrace; }
        else if (c == 91) { kind = tok.TokenKind::LBracket; }
        else if (c == 93) { kind = tok.TokenKind::RBracket; }
        else if (c == 58) {
            if (self.ch == 58) {
                self.read_char();
                kind = tok.TokenKind::ColonColon;
            } else {
                kind = tok.TokenKind::Colon;
            }
        }
        else if (c == 44) { kind = tok.TokenKind::Comma; }
        else if (c == 46) {
            if (self.ch == 46) {
                self.read_char();
                kind = tok.TokenKind::DotDot;
            } else {
                kind = tok.TokenKind::Dot;
            }
        }
        else if (c == 59) { kind = tok.TokenKind::Semicolon; }
        else if (c == 38) {
            if (self.ch == 38) {
                self.read_char();
                kind = tok.TokenKind::AndAnd;
            } else {
                kind = tok.TokenKind::Ampersand;
            }
        }
        else if (c == 124) {
            if (self.ch == 124) {
                self.read_char();
                kind = tok.TokenKind::PipePipe;
            } else {
                kind = tok.TokenKind::Pipe;
            }
        }
        else if (c == 94) { kind = tok.TokenKind::Caret; }
        else if (c == 63) { kind = tok.TokenKind::Question; }
        else if (c == 60) {
            if (self.ch == 60) {
                self.read_char();
                kind = tok.TokenKind::LessLess;
            } else if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::LessEqual;
            } else {
                kind = tok.TokenKind::Less;
            }
        }
        else if (c == 62) {
            if (self.ch == 62) {
                self.read_char();
                kind = tok.TokenKind::GreaterGreater;
            } else if (self.ch == 61) {
                self.read_char();
                kind = tok.TokenKind::GreaterEqual;
            } else {
                kind = tok.TokenKind::Greater;
            }
        }
        else if (c == 34) {
            kind = tok.TokenKind::StringLiteral(self.read_string());
        }
        else if (self.is_letter_val(c)) {
            let ident = self.read_identifier_with_start(c);
            kind = self.lookup_keyword(ident);
        }
        else if (self.is_digit_val(c)) {
            kind = self.read_number_token_with_start(c);
        }

        return tok.Token { kind: kind, line: cur_l, column: cur_c };
    }

    pub fn is_letter_val(self: Lexer, c: int) -> bool {
        return (c >= 97 && c <= 122) | (c >= 65 && c <= 90) | (c == 95);
    }

    pub fn is_digit_val(self: Lexer, c: int) -> bool {
        return (c >= 48 && c <= 57);
    }

    pub fn read_identifier_with_start(self: Lexer, start_ch: int) -> string {
        let start_pos = self.pos - 1;
        while (self.is_letter_val(self.ch) | self.is_digit_val(self.ch)) {
            self.read_char();
        }
        return str.sub(self.input, start_pos, self.pos);
    }

    pub fn read_number_token_with_start(self: Lexer, start_ch: int) -> tok.TokenKind {
        let start_pos = self.pos - 1;
        while (self.is_digit_val(self.ch)) {
            self.read_char();
        }
        let s = str.sub(self.input, start_pos, self.pos);
        return tok.TokenKind::IntLiteral(self.parse_int(s));
    }

    pub fn parse_int(self: Lexer, s: string) -> int {
        let len = str.length(s);
        let i = 0;
        let res = 0;
        while (len > i) {
            let c = str.char_at(s, i);
            res = res * 10 + (c - 48);
            i = i + 1;
        }
        return res;
    }

    pub fn read_string(self: Lexer) -> string {
        let start_pos = self.pos;
        while (self.ch != 34 && self.ch != 0) {
            if (self.ch == 92) { // \
                self.read_char();
            }
            self.read_char();
        }
        let lit = str.sub(self.input, start_pos, self.pos);
        self.read_char(); // skip closing "
        return lit;
    }
}